# essay
JS实现数据结构与算法杂记

## 数据结构
    数组和链表是最基础的线性数据结构，由它们衍生了栈，队列以及哈希(散列)表等等。
    非线性的数据结构还有树，图等。
    后续的内容将基于ES6语法实现这些常见的数据结构。

### 链表
    链表(linked list)是一种在物理上非连续，非顺序的数据结构，有若干节点组成。
    单向链表每个节点包含两个部分，一部分是存放元素本身的数据，一部分是指向下一个节点的引用(指针)。
    双向链表比单向列表稍微复杂一点，每个节点除了包含元素本身和下一个节点的指针，还包含了前置节点的指针。
    链表的特点是随机存储，顺序访问，不存在数组的扩容问题。因为要存储一些指针，相对数组要消耗更多存储空间。
    常见操作有查找节点，更新节点，插入节点，删除节点。
    查找的最坏时间复杂度O(n), 插入和删除的时间复杂度（1）
    单向链表: /data-structures/linked-list.js
    双向链表: /data-structures/double-linked-list.js

### 栈
    栈(stack)是一种线性数据结构，栈中的元素只能先入后出（First In Last Out,简称FILO）。
    最早进入的元素存放的位置叫栈底(bottom)，最后进入的元素存放的位置叫栈顶（top）。
    栈这种数据结构可以用数组实现，也可以用链表实现。
    常见操作有入栈和出栈，数组和链表实现的出入栈的时间复杂度都是O(1)。

    数组实现栈：/data-structures/stack-by-array.js
    链表实现栈：/data-structures/stack-by-linked-list.js

### 队列
    队列(queue)是一种线性数据结构，队列中的元素只能先入先出（First In First Out,简称FIFO）。
    最早进入的元素存放的位置叫队首(front)，最后进入的元素存放的位置叫队尾（rear）。
    队列这种数据结构，同样可以用数组实现，也可以用链表实现。
    常见操作有入队和出队, 时间复杂度均为O(1).

    数组实现队列如果存在不断出队，会导致队头做不的空间失去作用，可以采用循环队列的方式来维持队列容量的恒定。
    循环队列：
        队尾下标的计算公式：(队尾下标 + 1) % 数组长度
        队首下标的计算公式：(队首下标 + 1) % 数组长度

    数组实现循环队列：/data-structures/queue-by-array.js
    链表实现队列：/data-structures/queu-by-linked-list.js

### 哈希表
    哈希表也叫散列表(hash table), 这种数据结构提供键和值的映射关系，只要给出一个key，就可以高效的查询所匹配的value,时间复杂度接近O(1).

    哈希函数（散列函数）是把key和数组下标进行转换，由于哈希表是基于数组实现的，容量有限，当插入的数据越来越多，哈希表达到一定饱和度之后，就容易出现转换出来的下标相同，这叫做哈希冲突。

    解决哈希冲突的常见方法有以下两种：
        开链法
            两个键相同保存位置一样，开辟第二数组，也称第二个数组为链，适合空间小，数据量大
            元素不仅仅是对象，还是链表的头节点，数组位冲突，就插入对应的链表中。
            有链表的特性，操作简单，但是需要额外的空间存储指针。
        开放寻址法
            比如线性探测法。查找散列位置如果当前位置没有继续寻找下一个位置。存储数据较大较适合。
            特征有数组的特性，连续寻址，不需要指针的存储空间，但是操作复杂些。

        数组大小>=1.5*数据（开链法），数组大小>=2*数据（线性探测法）

    哈希表常见操作是读操作和写操作，但是哈希表是基于数组实现的，还涉及到扩容操作。

    什么时候进行扩容？
        当哈希表达到一定的饱和度是，哈希冲突的概率就越来越高，大量元素拥挤在相同的数组下标位置，形成过长的链表，会对后续插入和查找操作性能造成影响。
        扩容就是要队哈希表的长度进行扩展。扩容不仅仅是需要扩展长度，还需要重新进行hash计算。遍历原数组，重新计算hash到新数组中，因为长度变化后，hash规则也需要进行相应的相应的变化。

### 二叉树
    二叉树是树的一种特殊结构，每个节点最多有2个孩子节点。
    满二叉树：
        一个二叉树的所有非叶子节点都存在左右孩子节点，并且所有的叶子节点都在同一个层级上。
    完全二叉树：
        如果有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n.如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。
    二叉查找树是在二叉树的基础上增加了一些条件：
        如果左子树不为空，则左子树所有的节点的值均小于根节点的值
        如果右子树不为空，则右子树所有的节点的值均大于根节点的值
        左，右子树也都是二叉查找树。
    二叉树的存储包含三部分内容：
        存储的数据，左孩子的指针，右孩子的指针。
    应用场景：
        二叉树，满二叉树，完全二叉树，二叉查找树，主要应用时查找和维持相对顺序。
        二叉堆（本质是一个完全二叉树）用来实现堆排序和优先队列
            最大堆（父节点大于等于左右孩子节点）
            最小堆（父节点小于等于左右孩子节点）
            最大优先队列（最大元素优先出列）
            最小优先队列（最小元素优先出列）
    实现方法：
        用数组实现的是堆（一个完全二叉树，操作简单，不需要节点指针）
        用链表实现的常见的树（不一定是完全二叉树，衍生了二叉查找树(binary search tree)，AVL树，红黑树，区间树，B树等等）